<?xml version="1.0" encoding="utf-8" ?>

<!--
  This is a sample Configuration File for the VDS.Web.Server libraries HttpServer class
  Servers can be configured entirely in code or they can be instantiated by passing the path to a Configuration File like this and provided the file
  is valid they will be configured as specified in this file.
  
  The <server> element allows a @basedir attribute which is used to specify the base physical directory to which Request URLs are mapped if there
  is not a virtual directory into which they can be mapped
  
  The standard sections of the file are:
    <appSettings>     Specifies Application Settings
    <modules>         Specifies HTTP Modules
    <handlers>        Specifies HTTP Handlers
    <mimeTypes>       Specifies servable MIME Types for static content
    <virtualDirs>     Specifies Virtual Directories
    <loggers>         Specifies Loggers
    
  You can add additional configuration sections if you wish but you must specify a @loadwith attribute which points to a type
  implementing the VDS.Web.Configuration.IConfigurationLoader interface which can be used to load that part of the configuration
  
  e.g.
  
  <customSection loadwith="YourNamespace.YourType">
    ....
  </customSection>
-->

<server basedir=".">
  
  <appSettings>
    <!--
    This section is used to specify Application Settings which will be available via the HttpServer.State property
    
    Syntax is identical to .Net configuration files:
    <add key="name" value="some value" />
    
    All Application Settings specified in this way are strings though actual code may use HttpServer.State to store any kind of object
    -->
  </appSettings>

  <mimeTypes usedefault="true">
    <!--
    This section specifies the file extension and MIME type mappings which are used for determining whether static content can be served
    The @usedefault attribute sets whether a standard set of MIME types are automatically in-use (HTML, CSS, JS, Images and Text Files)
    There is only one MIME type allowed for each extension so it is possible to override default mappings (if @usedefault="true") is specified
    by specifying explicit mappings.

    Syntax is:
    <mimeType extension=".ext" type="application/something" binary="true" />
    
    The @extension attribute specifies the file extension to which this applies
    The @type attribute specifies the MIME Type
    The optional @binary attribute specifies whether files of this type should be transferred as binary rather than textual data (default false)
    -->
    
  </mimeTypes>

  <virtualDirs>
    <!--
    This section is used to specify Virtual Directories which will be used to map Request URLs into Physical Paths for serving physical content
    
    Syntax is:
    <virtualDir path="/somedir/" directory="C:\somefolder\" />
    
    The @path attribute must begin and end with /
    
    The order in which Virtual Directories is specified is irrelevant.  When HttpServer tries to map a Request URL to a physical path it tests
    the longest virtual directory path first. For example if you have two virtual directories /dir/ and /dir/subdir/ a request to /dir/subdir/
    would be mapped to the second virtual directory even if the first virtual directory contains an actual directory called subdir
    -->
  </virtualDirs>
  
  <modules>
    <!-- 
    This section specified Modules that are applied before and after a handler is used and may alter the request/response or cause the
    handler application to be skipped
    
    Syntax is:
    <module type="YourNamespace.YourType" />
    -->
    <prerequest>
      
    </prerequest>
    <preresponse>
      <module type="VDS.Web.Modules.LoggingModule" />
    </preresponse>
  </modules>
  
  <handlers>
    <!--
    This section specifies Handlers which are used to actually handle requests.  Handlers are applied after pre-request modules are before
    pre-response modules unless a pre-request modules signals that handlers should be skipped
    
    Syntax is very similar to Web.config:
    <handler verb="GET" path="*" type="YourNamespace.YourType" />
    
    Like Web.config the order of Handlers is important, Handler Mappings are queried to see if they will handle the request in strict order.
    Note that in code a handler may call the HttpServer.RemapHandler() method to indicate that another handler should take over the request
    but this will only succeed if the requested Handler is registered in the Handlers collection
    
    Handlers support 4 kinds of paths:
    *       Specifies that the Handler processes requests on any path
    /path/* Specifies that the Handler processes requests on any path under the base path
    /path   Specifies that the Handler processes requests at the specific path
    *.ext   Specifies that the Handler processes requests with a specific file extension
    -->
    <handler verb="*" path="*" type="VDS.Web.Server.Handlers.StaticFileHandler" />
  </handlers>

  <loggers>
    <!--
    This section is used to specify loggers which log activity on the web server
    
    Several types of loggers are supported:
    <filelogger file="filename" format="format string" />       Logs requests to a file using the given format
    <consolelogger format="format string" verbose="true" />    Logs errors and requests to console (only logs requests if verbose="true")
    
    See VDS.Web.Logging.ApacheStyleLogger for documentation of supported format strings
    
    You can specify custom logger elements if you provide a @loadwith attribute on the element in the same manner you'd specify custom configuration 
    settings
    -->
    <filelogger file="log.txt" format="common" />
  </loggers>
  
</server>
